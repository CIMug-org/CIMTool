package au.com.langdale.cimtoole.registries;

import java.util.Map;
import java.util.TreeMap;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IExtension;
import org.eclipse.core.runtime.IExtensionPoint;
import org.eclipse.core.runtime.IExtensionRegistry;
import org.eclipse.core.runtime.Platform;

import com.typesafe.config.Config;
import com.typesafe.config.ConfigFactory;
import com.typesafe.config.ConfigObject;

import au.com.langdale.cimtoole.builder.ProfileBuildlets.ProfileBuildlet;
import au.com.langdale.cimtoole.builder.ProfileBuildlets.TextBuildlet;
import au.com.langdale.cimtoole.builder.ProfileBuildlets.XSDBuildlet;

public class ProfileBuildletRegistryImpl implements ProfileBuildletRegistry {

	// Three variants of XSLT transform types of TransformBuildlets
	static enum TransformType {
		JSON, TEXT, XSD
	}

	private Map<String, ProfileBuildlet> buildlets;

	ProfileBuildletRegistryImpl() {
		buildlets = new TreeMap<String, ProfileBuildlet>();
		IExtensionRegistry registry = Platform.getExtensionRegistry();
		IExtensionPoint extPoint = registry.getExtensionPoint(ProfileBuildletRegistry.BUILDLET_REGISTRY_ID);

		IExtension[] pExts = extPoint.getExtensions();
		for (IExtension p : pExts) {
			for (IConfigurationElement el : p.getConfigurationElements()) {
				try {
					Object obj = el.createExecutableExtension("class");
					if (obj instanceof ProfileBuildlet) {
						ProfileBuildlet buildlet = (ProfileBuildlet) obj;
						String id = el.getAttribute("id");
						if (buildlet != null && id != null) {
							buildlets.put(id, buildlet);
						}
					}
				} catch (CoreException e) {
					e.printStackTrace();
				}
			}
		}

		try {
			Config buildersConfig = ConfigFactory.parseResources("builders.conf");
			ConfigObject builders = buildersConfig.getObject("builders");
			
			// Loop through each builder contained within the builders.conf file
			for (String builderKey : builders.keySet()) {
				
				// Obtain the type of TransformBuildlet to be created...
				String builderType = buildersConfig.getString("builders." + builderKey + ".type");
				TransformType type = TransformType.valueOf(builderType);
				
				// Obtain the extension of the file that will be generated by the builder...
				String ext = buildersConfig.getString("builders." + builderKey + ".ext");
				
				// Obtain the optional display text for the builder...
				String display = null;
				try {
					display = buildersConfig.getString("builders." + builderKey + ".display");
				} catch (Exception e) {
					// Do nothing...leave display == null
				}
				
				ProfileBuildlet buildlet = null;
				try {
					switch (type) {
					case JSON:
						buildlet = new TextBuildlet(builderKey, ext, display);
						break;
					case TEXT:
						buildlet = new TextBuildlet(builderKey, ext, display);
						break;
					case XSD:
						buildlet = new XSDBuildlet(builderKey, ext, display);
						break;
					}
					buildlets.put(builderKey, buildlet);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		} catch (Exception e) {
			// We log the exception, fail gracefully and proceed...
			e.printStackTrace();
		}
	}

	public ProfileBuildlet[] getBuildlets() {

		return buildlets.values().toArray(new ProfileBuildlet[buildlets.values().size()]);
		/*
		 * Not sure we need to make copies... try it as singletons for now
		 * 
		 * ProfileBuildlet[] copies = new ProfileBuildlet[buildlets.size()]; int i=0;
		 * for (ProfileBuildlet p : buildlets.values()){ try { copies[i++] =
		 * p.getClass().newInstance(); } catch (InstantiationException e) {
		 * e.printStackTrace(); } catch (IllegalAccessException e) {
		 * e.printStackTrace(); } } return copies;
		 */
	}

}
